<div id="video-call-container">
    <div id="videos">
        <video id="remote-video" autoplay playsinline></video>
        <video id="local-video" autoplay playsinline muted></video>
    </div>
    <div id="controls">
        <button id="create-invite" data-i18n="create_invitation">Create Invitation</button>
        <button id="accept-invite" data-i18n="accept_invitation" style="display: none;">Accept Invitation</button>
        <div id="response-container" style="display: none;">
            <input type="text" id="response-code" data-i18n="paste_response_placeholder" data-i18n-attr="placeholder" />
            <button id="submit-response" data-i18n="connect">Connect</button>
        </div>
        <div id="call-actions" style="display: none;">
            <button id="mic-toggle" data-i18n="mic_off">Mic Off</button>
            <button id="cam-toggle" data-i18n="cam_off">Cam Off</button>
        </div>
    </div>
    <div id="toast-container"></div>
    <div id="error-modal" style="display: none;">
        <div id="error-content">
            <p id="error-message"></p>
            <button id="close-modal" data-i18n="close">Close</button>
        </div>
    </div>
</div>

<script>
import { compact, decompact } from 'sdp-compact';

// Use global i18n system for static deployment
const t = (key: string) => (window as any).ZeroCallI18n?.t(key) || key;
const applyTranslations = () => (window as any).ZeroCallI18n?.applyTranslations();
const onLocaleChange = (cb: () => void) => (window as any).ZeroCallI18n?.onLocaleChange(cb);

const localVideo = document.getElementById('local-video') as HTMLVideoElement;
const remoteVideo = document.getElementById('remote-video') as HTMLVideoElement;
const createInviteBtn = document.getElementById('create-invite')! as HTMLButtonElement;
const acceptInviteBtn = document.getElementById('accept-invite')! as HTMLButtonElement;
const responseContainer = document.getElementById('response-container')!;
const responseCodeInput = document.getElementById('response-code')! as HTMLInputElement;
const submitResponseBtn = document.getElementById('submit-response')! as HTMLButtonElement;
const callActions = document.getElementById('call-actions') as HTMLDivElement;
const micToggleBtn = document.getElementById('mic-toggle') as HTMLButtonElement;
const camToggleBtn = document.getElementById('cam-toggle') as HTMLButtonElement;
const errorModal = document.getElementById('error-modal')!;
const errorMessage = document.getElementById('error-message')!;
const closeModalBtn = document.getElementById('close-modal')! as HTMLButtonElement;
const toastContainer = document.getElementById('toast-container')!;

let localStream: MediaStream;
let peerConnection: RTCPeerConnection;

const configuration = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }
    ]
};

// Helper functions for SDP compression
const encodeSDP = (sessionDescription: RTCSessionDescription): string => {
    console.log('encodeSDP called with:', sessionDescription.type);
    
    // Check if compact function is available
    if (typeof compact === 'undefined') {
        console.error('compact function is not available - import failed');
        return btoa(JSON.stringify(sessionDescription));
    }
    
    try {
        // Use more conservative compression options to maintain WebRTC compatibility
        const options = { 
            compress: true,
            mediaOptions: {
                replaceCandidateString: false, // Don't replace candidate strings to avoid transport type issues
                replaceMediaString: false, // Don't replace media strings
                removeMediaID: false, // Keep media IDs
                removeSetup: false, // Keep DTLS setup
                forceTrickle: false, // Don't force trickle
                compressFingerprint: true, // This should be safe
                compressConnection: false // Don't compress connection info
            }
        };
        
        console.log('Attempting SDP compression...');
        
        // Use the compact function which works with RTCSessionDescriptionInit
        const sessionDescInit = {
            type: sessionDescription.type,
            sdp: sessionDescription.sdp
        };
        
        console.log('Calling compact() with:', sessionDescInit.type, 'SDP length:', sessionDescInit.sdp.length);
        const compactedResult = compact(sessionDescInit, options);
        
        console.log('SDP Compression SUCCESS:');
        console.log('Original length:', btoa(JSON.stringify(sessionDescription)).length);
        console.log('Compressed length:', compactedResult.length);
        console.log('Compressed result (first 50 chars):', compactedResult.substring(0, 50));
        console.log('Compression ratio:', (compactedResult.length / btoa(JSON.stringify(sessionDescription)).length * 100).toFixed(1) + '%');
        
        // URL encode the compressed result to handle special characters
        const urlEncodedResult = encodeURIComponent(compactedResult);
        console.log('URL encoded length:', urlEncodedResult.length);
        console.log('URL encoded result (first 50 chars):', urlEncodedResult.substring(0, 50));
        
        return urlEncodedResult;
    } catch (error) {
        console.error('SDP compression FAILED:', error);
        console.error('Error details:', error instanceof Error ? error.message : String(error));
        // Fallback to original method if compression fails
        const fallback = btoa(JSON.stringify(sessionDescription));
        console.log('Using fallback encoding, length:', fallback.length);
        return fallback;
    }
};

const decodeSDP = (encodedData: string): RTCSessionDescription => {
    console.log('decodeSDP called with data length:', encodedData.length);
    console.log('Data starts with:', encodedData.substring(0, 20));
    
    // Heuristic: if data doesn't start with 'eyJ' (base64 of '{"type"'), it's likely compressed
    // Uncompressed data always starts with 'eyJ' because JSON starts with '{"type"'
    // URL-encoded data might start with '%' or other encoded characters
    const looksCompressed = !encodedData.startsWith('eyJ');
    
    if (looksCompressed) {
        console.log('Data appears to be compressed, attempting decompression...');
        try {
            // URL decode first to handle special characters
            const urlDecodedData = decodeURIComponent(encodedData);
            console.log('URL decoded length:', urlDecodedData.length);
            console.log('URL decoded data (first 50 chars):', urlDecodedData.substring(0, 50));
            
            // Use the same conservative options as compression
            const options = { 
                compress: true,
                mediaOptions: {
                    replaceCandidateString: false,
                    replaceMediaString: false,
                    removeMediaID: false,
                    removeSetup: false,
                    forceTrickle: false,
                    compressFingerprint: true,
                    compressConnection: false
                }
            };
            const decompactedResult = decompact(urlDecodedData, options);
            console.log('Decompression successful:', decompactedResult);
            return new RTCSessionDescription(decompactedResult);
        } catch (decompressError) {
            console.error('Decompression failed:', decompressError);
            throw new Error('Failed to decompress SDP data: ' + (decompressError instanceof Error ? decompressError.message : String(decompressError)));
        }
    } else {
        console.log('Data appears to be uncompressed base64 JSON, attempting to parse...');
        try {
            const data = JSON.parse(atob(encodedData));
            console.log('Successfully parsed uncompressed data:', data.type);
            return new RTCSessionDescription(data);
        } catch (parseError) {
            console.error('Failed to parse as base64 JSON:', parseError);
            // Last resort: try decompression anyway
            try {
                console.log('Trying decompression as last resort...');
                const options = { 
                    compress: true,
                    mediaOptions: {
                        replaceCandidateString: false,
                        replaceMediaString: false,
                        removeMediaID: false,
                        removeSetup: false,
                        forceTrickle: false,
                        compressFingerprint: true,
                        compressConnection: false
                    }
                };
                const decompactedResult = decompact(encodedData, options);
                console.log('Last resort decompression successful:', decompactedResult);
                return new RTCSessionDescription(decompactedResult);
            } catch (lastError) {
                console.error('All decoding methods failed:', lastError);
                throw new Error('Invalid SDP data - could not decode as compressed or uncompressed');
            }
        }
    }
};

const showToast = (message: string) => {
    if (!toastContainer) return;

    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;

    toastContainer.appendChild(toast);

    // Animate out and remove
    setTimeout(() => {
        toast.classList.add('fade-out');
        toast.addEventListener('transitionend', () => {
            toast.remove();
        });
    }, 3000); // Display for 3 seconds
};

const showError = (message: string) => {
    errorMessage.textContent = message;
    errorModal.style.display = 'flex';
};

const createInvitation = async () => {
    try {
        createInviteBtn.disabled = true;
        peerConnection = new RTCPeerConnection(configuration);

        if (localStream) {
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
        }

        peerConnection.ontrack = event => {
            remoteVideo.srcObject = event.streams[0];
        };

        const iceGatheringPromise = new Promise<void>(resolve => {
            let resolved = false;
            const resolveOnce = () => {
                if (!resolved) {
                    resolved = true;
                    resolve();
                }
            };

            setTimeout(resolveOnce, 2000);

            peerConnection.onicecandidate = event => {
                if (!event.candidate) {
                    resolveOnce();
                }
            };
        });

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        await iceGatheringPromise;

        const finalOffer = peerConnection.localDescription;
        if (finalOffer) {
            const encodedOffer = encodeSDP(finalOffer);
            const currentLocale = (window as any).ZeroCallI18n?.getCurrentLocale() || 'en';
            const inviteUrl = `${window.location.origin}${window.location.pathname}?invite=${encodedOffer}&lang=${currentLocale}`;

            navigator.clipboard.writeText(inviteUrl).then(() => {
                showToast(t('invitation_link_copied'));
            }).catch(err => {
                console.error('Could not copy link: ', err);
                showError(t('failed_to_copy_link'));
            });

            createInviteBtn.style.display = 'none';
            responseContainer.style.display = 'block';
        }
    } catch (error) {
        console.error(error);
        showError(t('failed_to_create_invitation'));
    }
};

const acceptInvitation = async (encodedOffer: string) => {
    createInviteBtn.style.display = 'none';
    acceptInviteBtn.style.display = 'block';

    acceptInviteBtn.onclick = async () => {
        await startLocalVideo();

        try {
            const offer = decodeSDP(encodedOffer);
            peerConnection = new RTCPeerConnection(configuration);

            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }

            peerConnection.ontrack = event => {
                const [remoteStream] = event.streams;
                remoteVideo.srcObject = remoteStream;
                setupSpeakingIndicator(remoteStream);
                callActions.style.display = 'flex';
            };

            await peerConnection.setRemoteDescription(offer);

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            const iceGatheringPromise = new Promise<void>(resolve => {
                let resolved = false;
                const resolveOnce = () => {
                    if (!resolved) {
                        resolved = true;
                        resolve();
                    }
                };

                setTimeout(resolveOnce, 2000);

                peerConnection.onicecandidate = event => {
                    if (!event.candidate) {
                        resolveOnce();
                    }
                };
            });

            await iceGatheringPromise;

            const finalAnswer = peerConnection.localDescription;
            if (finalAnswer) {
                const encodedResponse = encodeSDP(finalAnswer);

                navigator.clipboard.writeText(encodedResponse).then(() => {
                    showToast(t('response_code_copied'));
                }).catch(err => {
                    console.error('Could not copy code: ', err);
                    showError(t('failed_to_copy_response_code'));
                });

                acceptInviteBtn.style.display = 'none';
                const responseInfo = document.createElement('p');
                responseInfo.textContent = t('response_info_paste_back');
                responseInfo.style.textAlign = 'center';
                acceptInviteBtn.parentElement?.appendChild(responseInfo);
            }
        } catch (error) {
            console.error(error);
            showError(t('failed_to_create_invitation'));
        }
    };
};

const startLocalVideo = async () => {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
        callActions.style.display = 'flex';
        setupSpeakingIndicator(localStream);
    } catch (error) {
        console.error('Error accessing media devices:', error);
        showError(t('camera_permission_denied'));
    }
};

const setupSpeakingIndicator = (stream: MediaStream) => {
    const audioContext = new AudioContext();
    const analyser = audioContext.createAnalyser();
    const microphone = audioContext.createMediaStreamSource(stream);
    microphone.connect(analyser);
    
    analyser.fftSize = 256;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    const checkAudioLevel = () => {
        analyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
        
        if (average > 20) {
            localVideo.style.border = '3px solid #00ff00';
        } else {
            localVideo.style.border = '1px solid #333';
        }
        
        requestAnimationFrame(checkAudioLevel);
    };
    
    checkAudioLevel();
};

const submitResponse = async () => {
    const responseCode = responseCodeInput.value.trim();
    if (!responseCode) {
        showError(t('enter_response_code'));
        return;
    }

    try {
        const response = decodeSDP(responseCode);
        await peerConnection.setRemoteDescription(response);
        
        responseContainer.style.display = 'none';
        callActions.style.display = 'flex';
        
        showToast(t('connection_established'));
    } catch (error) {
        console.error('Error processing response:', error);
        showError(t('invalid_response_code'));
    }
};

const toggleMic = () => {
    if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            micToggleBtn.textContent = audioTrack.enabled ? t('mic_off') : t('mic_on');
        }
    }
};

const toggleCam = () => {
    if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            camToggleBtn.textContent = videoTrack.enabled ? t('cam_off') : t('cam_on');
        }
    }
};

// Initialize the app
const init = async () => {
    // Apply initial translations
    applyTranslations();
    
    // Set initial button labels
    micToggleBtn.textContent = t('mic_off');
    camToggleBtn.textContent = t('cam_off');
    
    // Listen for locale changes
    onLocaleChange(() => {
        applyTranslations();
        micToggleBtn.textContent = t('mic_off');
        camToggleBtn.textContent = t('cam_off');
    });
    
    // Set up event listeners
    createInviteBtn.addEventListener('click', async () => {
        await startLocalVideo();
        await createInvitation();
    });
    
    submitResponseBtn.addEventListener('click', submitResponse);
    micToggleBtn.addEventListener('click', toggleMic);
    camToggleBtn.addEventListener('click', toggleCam);
    closeModalBtn.addEventListener('click', () => {
        errorModal.style.display = 'none';
    });
    
    // Check for locale in URL and set it before anything else
    const urlParams = new URLSearchParams(window.location.search);
    const langParam = urlParams.get('lang');
    if (langParam && (window as any).ZeroCallI18n?.setLocale) {
        try {
            await (window as any).ZeroCallI18n.setLocale(langParam);
            // Re-apply translations after locale change
            applyTranslations();
            micToggleBtn.textContent = t('mic_off');
            camToggleBtn.textContent = t('cam_off');
        } catch (error) {
            console.warn('Failed to set locale from URL:', error);
        }
    }
    
    // Check for invitation in URL
    const inviteParam = urlParams.get('invite');
    if (inviteParam) {
        await acceptInvitation(inviteParam);
    }
};

// Wait for i18n to be ready
if ((window as any).ZeroCallI18n) {
    // i18n is already ready
    init();
} else {
    // Wait for i18n-ready event
    document.addEventListener('i18n-ready', init, { once: true });
}
</script>