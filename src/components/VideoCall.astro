<div id="video-call-container">
    <div id="videos">
        <video id="remote-video" autoplay playsinline></video>
        <video id="local-video" autoplay playsinline muted></video>
    </div>
    <div id="controls">
        <button id="create-invite" data-i18n="create_invitation">Create Invitation</button>
        <button id="accept-invite" data-i18n="accept_invitation" style="display: none;">Accept Invitation</button>
        <div id="response-container" style="display: none;">
            <input type="text" id="response-code" data-i18n="paste_response_placeholder" data-i18n-attr="placeholder" />
            <button id="submit-response" data-i18n="connect">Connect</button>
        </div>
        <div id="call-actions" style="display: none;">
            <button id="mic-toggle" data-i18n="mic_off">Mic Off</button>
            <button id="cam-toggle" data-i18n="cam_off">Cam Off</button>
        </div>
    </div>
    <div id="toast-container"></div>
    <div id="error-modal" style="display: none;">
        <div id="error-content">
            <p id="error-message"></p>
            <button id="close-modal" data-i18n="close">Close</button>
        </div>
    </div>
</div>

<script>
// Use global i18n system for static deployment
const t = (key: string) => (window as any).ZeroCallI18n?.t(key) || key;
const applyTranslations = () => (window as any).ZeroCallI18n?.applyTranslations();
const onLocaleChange = (cb: () => void) => (window as any).ZeroCallI18n?.onLocaleChange(cb);

const localVideo = document.getElementById('local-video') as HTMLVideoElement;
const remoteVideo = document.getElementById('remote-video') as HTMLVideoElement;
const createInviteBtn = document.getElementById('create-invite')! as HTMLButtonElement;
const acceptInviteBtn = document.getElementById('accept-invite')! as HTMLButtonElement;
const responseContainer = document.getElementById('response-container')!;
const responseCodeInput = document.getElementById('response-code')! as HTMLInputElement;
const submitResponseBtn = document.getElementById('submit-response')! as HTMLButtonElement;
const callActions = document.getElementById('call-actions') as HTMLDivElement;
const micToggleBtn = document.getElementById('mic-toggle') as HTMLButtonElement;
const camToggleBtn = document.getElementById('cam-toggle') as HTMLButtonElement;
const errorModal = document.getElementById('error-modal')!;
const errorMessage = document.getElementById('error-message')!;
const closeModalBtn = document.getElementById('close-modal')! as HTMLButtonElement;
const toastContainer = document.getElementById('toast-container')!;

let localStream: MediaStream;
let peerConnection: RTCPeerConnection;

const configuration = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }
    ]
};

const showToast = (message: string) => {
    if (!toastContainer) return;

    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;

    toastContainer.appendChild(toast);

    // Animate out and remove
    setTimeout(() => {
        toast.classList.add('fade-out');
        toast.addEventListener('transitionend', () => {
            toast.remove();
        });
    }, 3000); // Display for 3 seconds
};

const showError = (message: string) => {
    errorMessage.textContent = message;
    errorModal.style.display = 'flex';
};

const createInvitation = async () => {
    try {
        createInviteBtn.disabled = true;
        peerConnection = new RTCPeerConnection(configuration);

        if (localStream) {
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
        }

        peerConnection.ontrack = event => {
            remoteVideo.srcObject = event.streams[0];
        };

        const iceGatheringPromise = new Promise<void>(resolve => {
            let resolved = false;
            const resolveOnce = () => {
                if (!resolved) {
                    resolved = true;
                    resolve();
                }
            };

            setTimeout(resolveOnce, 2000);

            peerConnection.onicecandidate = event => {
                if (!event.candidate) {
                    resolveOnce();
                }
            };
        });

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        await iceGatheringPromise;

        const finalOffer = peerConnection.localDescription;
        if (finalOffer) {
            const encodedOffer = btoa(JSON.stringify(finalOffer));
            const currentLocale = (window as any).ZeroCallI18n?.getCurrentLocale() || 'en';
            const inviteUrl = `${window.location.origin}${window.location.pathname}?invite=${encodedOffer}&lang=${currentLocale}`;

            navigator.clipboard.writeText(inviteUrl).then(() => {
                showToast(t('invitation_link_copied'));
            }).catch(err => {
                console.error('Could not copy link: ', err);
                showError(t('failed_to_copy_link'));
            });

            createInviteBtn.style.display = 'none';
            responseContainer.style.display = 'block';
        }
    } catch (error) {
        console.error(error);
        showError(t('failed_to_create_invitation'));
    }
};

const acceptInvitation = async (encodedOffer: string) => {
    createInviteBtn.style.display = 'none';
    acceptInviteBtn.style.display = 'block';

    acceptInviteBtn.onclick = async () => {
        await startLocalVideo();

        try {
            const offer = JSON.parse(atob(encodedOffer));
            peerConnection = new RTCPeerConnection(configuration);

            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }

            peerConnection.ontrack = event => {
                const [remoteStream] = event.streams;
                remoteVideo.srcObject = remoteStream;
                setupSpeakingIndicator(remoteStream);
                callActions.style.display = 'flex';
            };

            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            const iceGatheringPromise = new Promise<void>(resolve => {
                let resolved = false;
                const resolveOnce = () => {
                    if (!resolved) {
                        resolved = true;
                        resolve();
                    }
                };

                setTimeout(resolveOnce, 2000);

                peerConnection.onicecandidate = event => {
                    if (!event.candidate) {
                        resolveOnce();
                    }
                };
            });

            await iceGatheringPromise;

            const finalAnswer = peerConnection.localDescription;
            if (finalAnswer) {
                const encodedResponse = btoa(JSON.stringify(finalAnswer));

                navigator.clipboard.writeText(encodedResponse).then(() => {
                    showToast(t('response_code_copied'));
                }).catch(err => {
                    console.error('Could not copy code: ', err);
                    showError(t('failed_to_copy_response_code'));
                });

                acceptInviteBtn.style.display = 'none';
                const responseInfo = document.createElement('p');
                responseInfo.textContent = t('response_info_paste_back');
                responseInfo.style.textAlign = 'center';
                acceptInviteBtn.parentElement?.appendChild(responseInfo);
            }
        } catch (error) {
            console.error(error);
            showError(t('failed_to_create_invitation'));
        }
    };
};

const startLocalVideo = async () => {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
        callActions.style.display = 'flex';
        setupSpeakingIndicator(localStream);
    } catch (error) {
        console.error('Error accessing media devices:', error);
        showError(t('camera_permission_denied'));
    }
};

const setupSpeakingIndicator = (stream: MediaStream) => {
    const audioContext = new AudioContext();
    const analyser = audioContext.createAnalyser();
    const microphone = audioContext.createMediaStreamSource(stream);
    microphone.connect(analyser);
    
    analyser.fftSize = 256;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    const checkAudioLevel = () => {
        analyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
        
        if (average > 20) {
            localVideo.style.border = '3px solid #00ff00';
        } else {
            localVideo.style.border = '1px solid #333';
        }
        
        requestAnimationFrame(checkAudioLevel);
    };
    
    checkAudioLevel();
};

const submitResponse = async () => {
    const responseCode = responseCodeInput.value.trim();
    if (!responseCode) {
        showError(t('enter_response_code'));
        return;
    }

    try {
        const response = JSON.parse(atob(responseCode));
        await peerConnection.setRemoteDescription(new RTCSessionDescription(response));
        
        responseContainer.style.display = 'none';
        callActions.style.display = 'flex';
        
        showToast(t('connection_established'));
    } catch (error) {
        console.error('Error processing response:', error);
        showError(t('invalid_response_code'));
    }
};

const toggleMic = () => {
    if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            micToggleBtn.textContent = audioTrack.enabled ? t('mic_off') : t('mic_on');
        }
    }
};

const toggleCam = () => {
    if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            camToggleBtn.textContent = videoTrack.enabled ? t('cam_off') : t('cam_on');
        }
    }
};

// Initialize the app
const init = async () => {
    // Apply initial translations
    applyTranslations();
    
    // Set initial button labels
    micToggleBtn.textContent = t('mic_off');
    camToggleBtn.textContent = t('cam_off');
    
    // Listen for locale changes
    onLocaleChange(() => {
        applyTranslations();
        micToggleBtn.textContent = t('mic_off');
        camToggleBtn.textContent = t('cam_off');
    });
    
    // Set up event listeners
    createInviteBtn.addEventListener('click', async () => {
        await startLocalVideo();
        await createInvitation();
    });
    
    submitResponseBtn.addEventListener('click', submitResponse);
    micToggleBtn.addEventListener('click', toggleMic);
    camToggleBtn.addEventListener('click', toggleCam);
    closeModalBtn.addEventListener('click', () => {
        errorModal.style.display = 'none';
    });
    
    // Check for locale in URL and set it before anything else
    const urlParams = new URLSearchParams(window.location.search);
    const langParam = urlParams.get('lang');
    if (langParam && (window as any).ZeroCallI18n?.setLocale) {
        try {
            await (window as any).ZeroCallI18n.setLocale(langParam);
            // Re-apply translations after locale change
            applyTranslations();
            micToggleBtn.textContent = t('mic_off');
            camToggleBtn.textContent = t('cam_off');
        } catch (error) {
            console.warn('Failed to set locale from URL:', error);
        }
    }
    
    // Check for invitation in URL
    const inviteParam = urlParams.get('invite');
    if (inviteParam) {
        await acceptInvitation(inviteParam);
    }
};

// Wait for i18n to be ready
if ((window as any).ZeroCallI18n) {
    // i18n is already ready
    init();
} else {
    // Wait for i18n-ready event
    document.addEventListener('i18n-ready', init, { once: true });
}
</script>